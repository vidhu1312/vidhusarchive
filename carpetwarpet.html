<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Carpet Reveal - Brightness Effect</title>
<style>
  body {
    margin: 0;
    padding: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background: #f0f0f0;
  }
  #container {
    position: relative;
    border: 1px solid #ccc;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  }
  canvas {
    display: block;
    cursor: pointer;
  }
  #overlay {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
  }
</style>
</head>
<body>
<div style="text-align: center; margin-bottom: 10px;">
  <button id="resetBtn" style="padding: 10px 20px; font-size: 16px; cursor: pointer; margin-right: 10px;">Reset</button>
  <span style="font-size: 14px; color: #666;">Hold Shift to restore | Two fingers on touch</span>
</div>
<div id="container">
  <canvas id="baseCanvas"></canvas>
  <canvas id="overlay"></canvas>
</div>
<script>
  const container = document.getElementById('container');
  const baseCanvas = document.getElementById('baseCanvas');
  const overlay = document.getElementById('overlay');
  const baseCtx = baseCanvas.getContext('2d');
  const overlayCtx = overlay.getContext('2d');
  const topImage = new Image();
  
  topImage.src = 'top.png';
  
  let isDrawing = false;
  let fadeMode = true; // true = fade, false = restore
  let lastX = 0;
  let lastY = 0;

  topImage.onload = () => {
    init();
  };
  
  topImage.onerror = () => {
    console.error('Failed to load top.png - make sure it is in the same folder');
    // Create a fallback
    baseCanvas.width = 600;
    baseCanvas.height = 400;
    overlay.width = 600;
    overlay.height = 400;
    baseCtx.fillStyle = '#8B4513';
    baseCtx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);
    baseCtx.fillStyle = 'white';
    baseCtx.font = '20px Arial';
    baseCtx.textAlign = 'center';
    baseCtx.fillText('Place top.png in same folder', baseCanvas.width/2, baseCanvas.height/2);
  };

  function init() {
    baseCanvas.width = topImage.width;
    baseCanvas.height = topImage.height;
    overlay.width = topImage.width;
    overlay.height = topImage.height;
    
    // Draw the base image normally
    baseCtx.drawImage(topImage, 0, 0);
    
    // Leave overlay completely transparent initially
    overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
  }

  function drawBrush(x, y, reverse = false) {
    const radius = 15;
    const grainCount = 40;
    
    if (!reverse) {
      // Fade mode - make it brighter
      overlayCtx.save();
      overlayCtx.filter = 'brightness(1.8) contrast(0.5)';
      overlayCtx.globalCompositeOperation = 'source-over';
      
      for (let i = 0; i < grainCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * radius;
        const px = x + Math.cos(angle) * distance;
        const py = y + Math.sin(angle) * distance;
        
        const opacity = 0.3 + Math.random() * 0.4;
        
        overlayCtx.globalAlpha = opacity;
        overlayCtx.drawImage(topImage, 
          px - 3, py - 3, 6, 6,
          px - 3, py - 3, 6, 6
        );
      }
      
      overlayCtx.globalAlpha = 0.2;
      overlayCtx.drawImage(topImage,
        x - radius * 0.5, y - radius * 0.5, radius, radius,
        x - radius * 0.5, y - radius * 0.5, radius, radius
      );
      
      overlayCtx.restore();
    } else {
      // Restore mode - erase the overlay
      overlayCtx.save();
      overlayCtx.globalCompositeOperation = 'destination-out';
      
      for (let i = 0; i < grainCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * radius;
        const px = x + Math.cos(angle) * distance;
        const py = y + Math.sin(angle) * distance;
        
        const opacity = 0.3 + Math.random() * 0.4;
        
        overlayCtx.globalAlpha = opacity;
        overlayCtx.beginPath();
        overlayCtx.arc(px, py, 2 + Math.random() * 2, 0, Math.PI * 2);
        overlayCtx.fill();
      }
      
      overlayCtx.globalAlpha = 0.2;
      overlayCtx.beginPath();
      overlayCtx.arc(x, y, radius * 0.5, 0, Math.PI * 2);
      overlayCtx.fill();
      
      overlayCtx.restore();
    }
  }

  baseCanvas.addEventListener('mousedown', (e) => {
    isDrawing = true;
    const rect = baseCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    lastX = x;
    lastY = y;
    
    // Detect if shift key is pressed for reverse
    drawBrush(x, y, e.shiftKey);
  });

  baseCanvas.addEventListener('mousemove', (e) => {
    if (!isDrawing) return;
    const rect = baseCanvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Detect if shift key is pressed for reverse
    drawBrush(x, y, e.shiftKey);
    
    lastX = x;
    lastY = y;
  });

  baseCanvas.addEventListener('mouseup', () => {
    isDrawing = false;
  });

  baseCanvas.addEventListener('mouseleave', () => {
    isDrawing = false;
  });

  // Touch support
  baseCanvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    isDrawing = true;
    const rect = baseCanvas.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    lastX = x;
    lastY = y;
    
    // Two finger touch for reverse
    drawBrush(x, y, e.touches.length >= 2);
  });

  baseCanvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (!isDrawing) return;
    const rect = baseCanvas.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    
    // Two finger touch for reverse
    drawBrush(x, y, e.touches.length >= 2);
    
    lastX = x;
    lastY = y;
  });

  baseCanvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    isDrawing = false;
  });

  // Reset button
  document.getElementById('resetBtn').addEventListener('click', () => {
    overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
  });
</script>
</body>
</html>