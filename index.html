<script>
const container = document.getElementById('container');
const baseCanvas = document.getElementById('baseCanvas');
const overlay = document.getElementById('overlay');
const baseCtx = baseCanvas.getContext('2d');
const overlayCtx = overlay.getContext('2d');
const onboardingPage = document.getElementById('onboarding');
const carpetPage = document.getElementById('carpetPage');
const screen = document.getElementById('screen');

let currentCarpet = null;
let topImage = new Image();
let isDrawing = false;
let fadeMode = true;

// --- Helper Functions ---

// Fills the overlay canvas with a semi-transparent white/fade color
function fillOverlayWithFade() {
    overlayCtx.globalCompositeOperation = "source-over"; // Ensure drawing is additive
    // Using a light, semi-transparent color for the "fade" effect
    overlayCtx.fillStyle = "rgba(255, 255, 255, 0.5)"; 
    overlayCtx.fillRect(0, 0, overlay.width, overlay.height);
}

// --- Carpet Selection and Initialization ---

document.querySelectorAll('.carpet-option').forEach(option => {
    option.addEventListener('click', () => {
        const carpetType = option.dataset.carpet;
        loadCarpet(carpetType);
    });
});

function loadCarpet(carpetType) {
    // Always start with fade mode when a new carpet is opened
    fadeMode = true;
    screen.classList.remove('dark-mode');
    document.getElementById('modeBtn').textContent = 'Restore Mode'; // Label shows NEXT mode

    currentCarpet = carpetType;
    topImage = new Image();
    topImage.crossOrigin = "anonymous";
    topImage.src = `${carpetType}.png`;

    topImage.onload = () => {
        init();
        onboardingPage.classList.remove('active');
        carpetPage.classList.add('active');
    };

    topImage.onerror = () => {
        console.error(`Failed to load ${carpetType}.png`);
        
        // Fallback initialization
        baseCanvas.width = 700;
        baseCanvas.height = 900;
        overlay.width = 700;
        overlay.height = 900;

        // Draw fallback base pattern
        baseCtx.fillStyle = carpetType === 'top' ? '#c9a582' : carpetType === 'middle' ? '#8b6f47' : '#4a2f1a';
        baseCtx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);
        
        baseCtx.fillStyle = 'white';
        baseCtx.font = '20px Georgia';
        baseCtx.textAlign = 'center';
        baseCtx.fillText(`Draw on me! (${carpetType}.png not found)`, baseCanvas.width/2, 50);

        fillOverlayWithFade(); // Apply initial fade layer to fallback

        onboardingPage.classList.remove('active');
        carpetPage.classList.add('active');
    };
}

function init() {
    const maxWidth = 700;
    const maxHeight = 900;

    let scale = Math.min(maxWidth / topImage.width, maxHeight / topImage.height);

    baseCanvas.width = topImage.width * scale;
    baseCanvas.height = topImage.height * scale;
    overlay.width = baseCanvas.width;
    overlay.height = baseCanvas.height;

    // Draw the original carpet image on the base canvas
    baseCtx.drawImage(topImage, 0, 0, baseCanvas.width, baseCanvas.height);
    
    // Fill the overlay with the initial semi-transparent fade layer
    fillOverlayWithFade();
}

function getCanvasCoords(e) {
    const rect = baseCanvas.getBoundingClientRect();
    if (e.touches) {
        return {
            x: e.touches[0].clientX - rect.left,
            y: e.touches[0].clientY - rect.top
        };
    }
    return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
    };
}

// --- Drawing Logic with Rough Edges ---

function drawBrush(x, y) {
    const radius = 25;
    const edgeRoughness = 20; // Number of small irregular edge scatter points
    const brushColor = 'rgba(0, 0, 0, 1)'; // Use opaque color for composite operations

    overlayCtx.save();
    
    if (fadeMode) {
        // Fade Mode: Erase the semi-transparent overlay to reveal the base image.
        // This is the desired 'faded' effect.
        overlayCtx.globalCompositeOperation = "destination-out";
        document.querySelector('.instructions').textContent = "Draw to fade • Switch mode to restore"; // Update instruction text
    } else {
        // Restore Mode: Draw the semi-transparent color back onto the overlay.
        // This 'restores' the fade layer, covering the base image again.
        overlayCtx.globalCompositeOperation = "source-over";
        // When restoring, we draw the original fade color
        brushColor = 'rgba(255, 255, 255, 0.5)'; 
        document.querySelector('.instructions').textContent = "Draw to restore • Switch mode to fade"; // Update instruction text
    }

    // 1. Draw a main circular shape
    overlayCtx.fillStyle = brushColor;
    overlayCtx.beginPath();
    overlayCtx.arc(x, y, radius * 0.9, 0, Math.PI * 2); // Slightly smaller for better edge control
    overlayCtx.fill();

    // 2. Add rough edges (small, random dots/squares around the main circle)
    for (let i = 0; i < edgeRoughness; i++) {
        const angle = Math.random() * Math.PI * 2;
        // Scatter points from about 70% of the radius to outside the radius
        const dist = radius * (0.7 + Math.random() * 0.6); 
        const nx = x + Math.cos(angle) * dist;
        const ny = y + Math.sin(angle) * dist;
        
        // Draw small, rough squares/dots
        const size = 1 + Math.random() * 2;
        overlayCtx.fillRect(nx, ny, size, size);
    }
    
    overlayCtx.restore();
}

function startDrawing(e) {
    e.preventDefault();
    isDrawing = true;
    const coords = getCanvasCoords(e);
    drawBrush(coords.x, coords.y);
}

function draw(e) {
    e.preventDefault();
    if (!isDrawing) return;
    const coords = getCanvasCoords(e);
    drawBrush(coords.x, coords.y);
}

function stopDrawing(e) {
    e.preventDefault();
    isDrawing = false;
}

// Mouse events
baseCanvas.addEventListener('mousedown', startDrawing);
baseCanvas.addEventListener('mousemove', draw);
baseCanvas.addEventListener('mouseup', stopDrawing);
baseCanvas.addEventListener('mouseleave', stopDrawing);

// Touch events
baseCanvas.addEventListener('touchstart', startDrawing);
baseCanvas.addEventListener('touchmove', draw);
baseCanvas.addEventListener('touchend', stopDrawing);

// --- Buttons ---

document.getElementById('resetBtn').addEventListener('click', () => {
    // Reset means re-applying the initial fade layer
    fillOverlayWithFade();
    // Ensure instructions are correct after reset
    if (fadeMode) {
        document.querySelector('.instructions').textContent = "Draw to fade • Switch mode to restore";
    } else {
        document.querySelector('.instructions').textContent = "Draw to restore • Switch mode to fade";
    }
});

document.getElementById('modeBtn').addEventListener('click', () => {
    fadeMode = !fadeMode;
    // Label shows the mode the button will switch TO (the *opposite* of current mode)
    document.getElementById('modeBtn').textContent = fadeMode ? 'Restore Mode' : 'Fade Mode'; 

    // Toggle dark mode (cosmetic change for "restore" mode)
    if (fadeMode) {
        screen.classList.remove('dark-mode');
        document.querySelector('.instructions').textContent = "Draw to fade • Switch mode to restore";
    } else {
        screen.classList.add('dark-mode');
        document.querySelector('.instructions').textContent = "Draw to restore • Switch mode to fade";
    }
});

document.getElementById('backBtn').addEventListener('click', () => {
    carpetPage.classList.remove('active');
    onboardingPage.classList.add('active');
    overlayCtx.clearRect(0, 0, overlay.width, overlay.height); // Clear overlay on back
    screen.classList.remove('dark-mode');
});
</script>


