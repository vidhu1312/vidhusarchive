<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Carpet Warpet</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
margin: 0;
padding: 0;
display: flex;
justify-content: center;
align-items: center;
min-height: 100vh;
background: #d4d1cd;
font-family: 'Georgia', serif;
}

#ipadFrame {
width: 820px;
height: 1180px;
background: #1a1a1a;
border-radius: 40px;
padding: 60px 20px;
box-shadow: 0 20px 60px rgba(0,0,0,0.3);
position: relative;
}

#ipadFrame::before {
content: '';
position: absolute;
top: 20px;
left: 50%;
transform: translateX(-50%);
width: 80px;
height: 6px;
background: #333;
border-radius: 3px;
}

#screen {
width: 100%;
height: 100%;
background: white;
border-radius: 20px;
overflow: hidden;
position: relative;
transition: background-color 0.3s ease, color 0.3s ease;
}

#screen.dark-mode {
background: #1a1a1a;
color: white;
}

.page {
display: none;
width: 100%;
height: 100%;
padding: 40px;
}

.page.active { 
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
}

#onboarding {
text-align: center;
}

#onboarding h1 {
font-size: 72px;
font-weight: 400;
margin-bottom: 60px;
color: #1a1a1a;
}

.carpet-grid {
display: grid;
grid-template-columns: repeat(3, 1fr);
gap: 20px;
margin-top: 40px;
}

.carpet-option {
width: 180px;
height: 240px;
border: 3px solid #ddd;
border-radius: 16px;
cursor: pointer;
transition: all 0.3s;
overflow: hidden;
position: relative;
}

.carpet-option:hover {
border-color: #667eea;
transform: scale(1.05);
}

.carpet-option img {
width: 100%;
height: 100%;
object-fit: cover;
display: block;
}

.carpet-label {
margin-top: 10px;
font-size: 18px;
color: #000;
}

#carpetPage {
padding: 20px;
justify-content: flex-start;
}

.mode-toggle-container {
display: flex;
justify-content: center;
width: 100%;
margin-bottom: 25px;
}

#modeBtn {
padding: 16px 40px;
font-size: 20px;
font-weight: 600;
cursor: pointer;
border: none;
border-radius: 16px;
font-family: 'Georgia', serif;
transition: all 0.3s;
background: linear-gradient(135deg, #d6c9b4 0%, #b8a78b 100%);
color: #3a3a3a;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
letter-spacing: 0.5px;
}

#modeBtn:hover {
transform: translateY(-2px);
box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
background: linear-gradient(135deg, #c9bca7 0%, #a89a7e 100%);
}

#modeBtn:active {
transform: translateY(0);
}

.controls {
display: flex;
gap: 15px;
margin-bottom: 20px;
width: 100%;
justify-content: space-between;
align-items: center;
}

.btn {
padding: 12px 24px;
font-size: 16px;
cursor: pointer;
border: none;
border-radius: 12px;
font-family: 'Georgia', serif;
transition: all 0.2s;
background: #667eea;
color: white;
}

.btn:hover {
background: #5568d3;
transform: translateY(-2px);
}

.btn-secondary {
background: #f0f0f0;
color: #000;
}

.btn-secondary:hover {
background: #e0e0e0;
}

#screen.dark-mode .btn-secondary {
background: #333;
color: white;
}

#screen.dark-mode .btn-secondary:hover {
background: #444;
}

.instructions {
font-size: 14px;
color: #000;
}

#screen.dark-mode .instructions {
color: #ccc;
}

#container {
position: relative;
box-shadow: 0 4px 12px rgba(0,0,0,0.1);
border-radius: 12px;
overflow: hidden;
}

canvas {
display: block;
cursor: crosshair;
}

/* #overlay is no longer used for drawing, can remove or make transparent */
#overlay {
position: absolute;
top: 0;
left: 0;
pointer-events: none; /* Keep pointer events none as it's not the drawing surface anymore */
opacity: 0; /* Make it invisible */
}
</style>
</head>
<body>
<div id="ipadFrame">
<div id="screen">
<div id="onboarding" class="page active">
<h1>Carpet Warpet</h1>
<p style="font-size: 20px; color: #000; margin-bottom: 20px;">Choose your carpet</p>
<div class="carpet-grid">
<div class="carpet-option" data-carpet="top">
<img src="top.png" alt="Top Carpet" onerror="this.style.display='none'; this.parentElement.style.background='linear-gradient(135deg, #e0c3a5 0%, #c9a582 100%)';">
</div>
<div class="carpet-option" data-carpet="middle">
<img src="middle.png" alt="Middle Carpet" onerror="this.style.display='none'; this.parentElement.style.background='linear-gradient(135deg, #b5926a 0%, #8b6f47 100%)';">
</div>
<div class="carpet-option" data-carpet="bottom">
<img src="bottom.png" alt="Bottom Carpet" onerror="this.style.display='none'; this.parentElement.style.background='linear-gradient(135deg, #6b4423 0%, #4a2f1a 100%)';">
</div>
</div>
</div>

<div id="carpetPage" class="page">
<div class="mode-toggle-container">
<button id="modeBtn" class="btn">Erase Mode</button>
</div>
<div class="controls">
<button id="backBtn" class="btn btn-secondary">← Back</button>
<span class="instructions">Draw to fade • Switch mode to erase</span>
<button id="resetBtn" class="btn btn-secondary">Reset</button>
</div>
<div id="container">
<canvas id="baseCanvas"></canvas>
<canvas id="overlay"></canvas> 
</div>
</div>
</div>
</div>

<script>
const baseCanvas = document.getElementById('baseCanvas');
const baseCtx = baseCanvas.getContext('2d');
// Note: #overlay element is ignored for this pixel-based approach, which is cleaner
const onboardingPage = document.getElementById('onboarding');
const carpetPage = document.getElementById('carpetPage');
const screen = document.getElementById('screen');
const instructionsSpan = document.querySelector('.instructions');

let currentCarpet = null;
let originalCarpetImage = new Image();
let isDrawing = false;
let fadeMode = true;

// --- Hidden Canvases for State Management ---
const hiddenCanvas = document.createElement('canvas'); // Stores PRISTINE (Original) data
const hiddenCtx = hiddenCanvas.getContext('2d');

const fadedCanvas = document.createElement('canvas'); // Stores FADED (Brushed) data
const fadedCtx = fadedCanvas.getContext('2d');

// --- Hidden Canvas for Brush Texture Masking ---
const maskCanvas = document.createElement('canvas');
const maskCtx = maskCanvas.getContext('2d');

// --- Configuration ---
const BRUSH_RADIUS = 25; // Main brush size
const FADE_STRENGTH_GLOBAL = 0.5; // Fixed strength for the one-time fade effect (0 to 1)

// --- Helper Functions ---

/**
 * Applies a fixed fade (desaturation/lighten) to a single pixel.
 * Used only once during initialization to create the 'fadedCanvas' state.
 */
function applyFixedFade(r, g, b) { 
    // Calculate Luminosity (grayscale value)
    const gray = (r * 0.299 + g * 0.587 + b * 0.114);
    
    // Desaturation: Blend current color toward gray (using global strength)
    const desatR = r + (gray - r) * FADE_STRENGTH_GLOBAL; 
    const desatG = g + (gray - g) * FADE_STRENGTH_GLOBAL;
    const desatB = b + (gray - b) * FADE_STRENGTH_GLOBAL;

    // Lightening: Blend desaturated color toward a light-gray (220)
    const targetLight = 220;
    const lightenAmount = FADE_STRENGTH_GLOBAL * 0.5;

    return {
        r: Math.min(255, desatR + (targetLight - desatR) * lightenAmount),
        g: Math.min(255, desatG + (targetLight - desatG) * lightenAmount),
        b: Math.min(255, desatB + (targetLight - desatB) * lightenAmount)
    };
}

/**
 * Renders the grainy texture onto the maskCanvas context.
 * This texture acts as the stencil for pixel operations.
 */
function drawGrainMask(radius) {
    maskCanvas.width = radius * 2;
    maskCanvas.height = radius * 2;
    maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
    
    const center = radius;
    const grainCount = 40;
    
    maskCtx.fillStyle = `rgba(0, 0, 0, 1)`;
    maskCtx.globalCompositeOperation = 'source-over';
    
    // Draw particles for texture
    for (let i = 0; i < grainCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * radius * 0.9;
        const px = center + Math.cos(angle) * distance;
        const py = center + Math.sin(angle) * distance;
        
        maskCtx.beginPath();
        maskCtx.arc(px, py, 2 + Math.random() * 1.5, 0, Math.PI * 2);
        maskCtx.fill();
    }
}

/**
 * Runs the fixed fade effect on an entire canvas once.
 */
function preCalculateFadedState(sourceCtx, targetCtx, width, height) {
    const imageData = sourceCtx.getImageData(0, 0, width, height);
    const pixels = imageData.data;

    for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        
        const faded = applyFixedFade(r, g, b);
        
        pixels[i] = faded.r;
        pixels[i + 1] = faded.g;
        pixels[i + 2] = faded.b;
    }

    targetCtx.putImageData(imageData, 0, 0);
}

// --- Image Loading and Initialization (Modified to include faded state) ---

document.querySelectorAll('.carpet-option').forEach(option => {
    option.addEventListener('click', () => {
        const carpetType = option.dataset.carpet;
        loadCarpet(carpetType);
    });
});

function loadCarpet(carpetType) {
    fadeMode = true; 
    screen.classList.remove('dark-mode');
    document.getElementById('modeBtn').textContent = 'Erase Mode'; // Changed to Erase
    instructionsSpan.textContent = "Draw to fade • Switch mode to erase"; // Changed to erase

    currentCarpet = carpetType;
    originalCarpetImage = new Image();
    originalCarpetImage.crossOrigin = "anonymous";
    originalCarpetImage.src = `${carpetType}.png`;

    originalCarpetImage.onload = () => {
        init();
        onboardingPage.classList.remove('active');
        carpetPage.classList.add('active');
    };

    originalCarpetImage.onerror = () => {
        console.error(`Failed to load ${carpetType}.png`);
        
        baseCanvas.width = 700;
        baseCanvas.height = 900;
        hiddenCanvas.width = fadedCanvas.width = baseCanvas.width;
        hiddenCanvas.height = fadedCanvas.height = baseCanvas.height;

        const fallbackColor = carpetType === 'top' ? '#c9a582' : carpetType === 'middle' ? '#8b6f47' : '#4a2f1a';
        
        // Draw fallback to hidden (pristine)
        hiddenCtx.fillStyle = fallbackColor;
        hiddenCtx.fillRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);
        
        // Calculate and draw fallback to faded
        preCalculateFadedState(hiddenCtx, fadedCtx, hiddenCanvas.width, hiddenCanvas.height);

        // Draw pristine state to display
        baseCtx.drawImage(hiddenCanvas, 0, 0); 
        
        onboardingPage.classList.remove('active');
        carpetPage.classList.add('active');
    };
}

function init() {
    const maxWidth = 700;
    const maxHeight = 900;

    let scale = Math.min(maxWidth / originalCarpetImage.width, maxHeight / originalCarpetImage.height);

    baseCanvas.width = originalCarpetImage.width * scale;
    baseCanvas.height = originalCarpetImage.height * scale;
    const w = baseCanvas.width;
    const h = baseCanvas.height;

    hiddenCanvas.width = fadedCanvas.width = w;
    hiddenCanvas.height = fadedCanvas.height = h;

    // 1. Draw original image to HIDDEN canvas (PRISTINE state)
    hiddenCtx.drawImage(originalCarpetImage, 0, 0, w, h);
    
    // 2. Calculate and draw the FADED state to fadedCanvas
    fadedCtx.drawImage(originalCarpetImage, 0, 0, w, h); // Start with pristine image
    preCalculateFadedState(fadedCtx, fadedCtx, w, h); // Apply the fixed pixel fade

    // 3. Draw PRISTINE state to BASE canvas for initial display
    baseCtx.drawImage(originalCarpetImage, 0, 0, w, h);
}

function getCanvasCoords(e) {
    const rect = baseCanvas.getBoundingClientRect();
    if (e.touches) {
        return {
            x: e.touches[0].clientX - rect.left,
            y: e.touches[0].clientY - rect.top
        };
    }
    return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
    };
}

// --- REVISED DRAW BRUSH (Now simply copies fixed states) ---

function drawBrush(x, y) {
    const brushRadius = BRUSH_RADIUS;

    // Calculate the bounding box for pixel manipulation
    const minX = Math.max(0, x - brushRadius);
    const minY = Math.max(0, y - brushRadius);
    const maxX = Math.min(baseCanvas.width, x + brushRadius);
    const maxY = Math.min(baseCanvas.height, y + brushRadius);
    const width = maxX - minX;
    const height = maxY - minY;

    if (width <= 0 || height <= 0) return;

    // 1. Determine source data context (Original or Faded)
    const sourceCtx = fadeMode ? fadedCtx : hiddenCtx;
    
    // 2. Get the target image data (the current display state)
    const currentImageData = baseCtx.getImageData(minX, minY, width, height);
    const currentPixels = currentImageData.data;

    // 3. Get the source (fixed state) image data
    const sourceImageData = sourceCtx.getImageData(minX, minY, width, height);
    const sourcePixels = sourceImageData.data;

    // 4. Draw the desired grain texture onto the temporary mask canvas
    drawGrainMask(brushRadius);
    const brushTexture = maskCtx.getImageData(0, 0, width, height).data;

    // 5. Copy pixels based on the brush texture
    for (let i = 0; i < currentPixels.length; i += 4) {
        // Only modify the pixel if the brush texture hits it
        if (brushTexture[i + 3] > 10) { 
            // Copy RGB values from the fixed source state (Faded or Original)
            currentPixels[i] = sourcePixels[i];
            currentPixels[i + 1] = sourcePixels[i + 1];
            currentPixels[i + 2] = sourcePixels[i + 2];
            // Alpha (i+3) remains the same
        }
    }

    // 6. Put the modified pixel data back onto the base canvas
    baseCtx.putImageData(currentImageData, minX, minY);
}


function startDrawing(e) {
    e.preventDefault();
    isDrawing = true;
    const coords = getCanvasCoords(e);
    drawBrush(coords.x, coords.y);
}

function draw(e) {
    e.preventDefault();
    if (!isDrawing) return;
    const coords = getCanvasCoords(e);
    drawBrush(coords.x, coords.y);
}

function stopDrawing(e) {
    e.preventDefault();
    isDrawing = false;
}

// Attach all events to the #baseCanvas (the visible drawing surface)
baseCanvas.addEventListener('mousedown', startDrawing);
baseCanvas.addEventListener('mousemove', draw);
baseCanvas.addEventListener('mouseup', stopDrawing);
baseCanvas.addEventListener('mouseleave', stopDrawing);

// Touch events
baseCanvas.addEventListener('touchstart', startDrawing);
baseCanvas.addEventListener('touchmove', draw);
baseCanvas.addEventListener('touchend', stopDrawing);

// --- Buttons ---

document.getElementById('resetBtn').addEventListener('click', () => {
    // Reset draws the entire PRISTINE state from hiddenCanvas
    baseCtx.drawImage(hiddenCanvas, 0, 0, baseCanvas.width, baseCanvas.height);
    
    if (fadeMode) {
        instructionsSpan.textContent = "Draw to fade • Switch mode to erase"; // Changed to erase
    } else {
        instructionsSpan.textContent = "Draw to erase • Switch mode to fade"; // Changed to erase
    }
});

document.getElementById('modeBtn').addEventListener('click', () => {
    fadeMode = !fadeMode;
    document.getElementById('modeBtn').textContent = fadeMode ? 'Erase Mode' : 'Fade Mode'; // Changed to Erase 

    if (fadeMode) {
        screen.classList.remove('dark-mode');
        instructionsSpan.textContent = "Draw to fade • Switch mode to erase"; // Changed to erase
    } else {
        screen.classList.add('dark-mode');
        instructionsSpan.textContent = "Draw to erase • Switch mode to fade"; // Changed to erase
    }
});

document.getElementById('backBtn').addEventListener('click', () => {
    carpetPage.classList.remove('active');
    onboardingPage.classList.add('active');
    baseCtx.clearRect(0, 0, baseCanvas.width, baseCanvas.height);
    screen.classList.remove('dark-mode');
});
</script>
</body>
</html>
