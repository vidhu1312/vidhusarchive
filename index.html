<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Carpet Warpet</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    margin: 0;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    font-family: 'Georgia', serif;
  }
  
  #ipadFrame {
    width: 90vw;
    max-width: 820px;
    height: 90vh;
    max-height: 1180px;
    background: #1a1a1a;
    border-radius: 40px;
    padding: 60px 20px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    position: relative;
  }
  
  #ipadFrame::before {
    content: '';
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 6px;
    background: #333;
    border-radius: 3px;
  }
  
  #screen {
    width: 100%;
    height: 100%;
    background: white;
    border-radius: 20px;
    overflow: hidden;
    position: relative;
  }
  
  .page {
    display: none;
    width: 100%;
    height: 100%;
    padding: 40px;
  }
  
  .page.active {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  
  #onboarding {
    text-align: center;
  }
  
  #onboarding h1 {
    font-size: 72px;
    font-weight: 400;
    font-style: italic;
    margin-bottom: 60px;
    color: #1a1a1a;
  }
  
  .carpet-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    margin-top: 40px;
  }
  
  .carpet-option {
    width: 180px;
    height: 240px;
    border: 3px solid #ddd;
    border-radius: 16px;
    cursor: pointer;
    transition: all 0.3s;
    overflow: hidden;
    position: relative;
  }
  
  .carpet-option:hover {
    border-color: #667eea;
    transform: scale(1.05);
  }
  
  .carpet-option img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  
  .carpet-label {
    margin-top: 10px;
    font-size: 18px;
    color: #000;
  }
  
  #carpetPage {
    padding: 20px;
    justify-content: flex-start;
  }
  
  .controls {
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
    width: 100%;
    justify-content: space-between;
    align-items: center;
  }
  
  .btn {
    padding: 12px 24px;
    font-size: 16px;
    cursor: pointer;
    border: none;
    border-radius: 12px;
    font-family: 'Georgia', serif;
    transition: all 0.2s;
    background: #667eea;
    color: white;
  }
  
  .btn:hover {
    background: #5568d3;
    transform: translateY(-2px);
  }
  
  .btn-secondary {
    background: #f0f0f0;
    color: #000;
  }
  
  .btn-secondary:hover {
    background: #e0e0e0;
  }
  
  .instructions {
    font-size: 14px;
    color: #000;
    font-style: italic;
  }
  
  #container {
    position: relative;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    border-radius: 12px;
    overflow: hidden;
  }
  
  canvas {
    display: block;
    cursor: crosshair;
  }
  
  /* CRITICAL: The overlay canvas MUST be on top and interactive for the brush grain technique */
  #overlay {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: auto; /* Allow interaction */
    opacity: 1; /* Fully visible */
  }
  /* The base canvas holds the image. We draw *onto* the overlay. */
</style>
</head>
<body>
<div id="ipadFrame">
  <div id="screen">
    <div id="onboarding" class="page active">
      <h1>Carpet Warpet</h1>
      <p style="font-size: 20px; color: #000; margin-bottom: 20px;">Choose your carpet</p>
      <div class="carpet-grid">
        <div style="text-align: center;">
          <div class="carpet-option" data-carpet="top">
            <img src="top.png" alt="Top Carpet" onerror="this.style.display='none'; this.parentElement.style.background='linear-gradient(135deg, #e0c3a5 0%, #c9a582 100%)';">
          </div>
          <div class="carpet-label">Top</div>
        </div>
        <div style="text-align: center;">
          <div class="carpet-option" data-carpet="middle">
             <img src="middle.png" alt="Middle Carpet" onerror="this.style.display='none'; this.parentElement.style.background='linear-gradient(135deg, #b5926a 0%, #8b6f47 100%)';">
          </div>
          <div class="carpet-label">Middle</div>
        </div>
        <div style="text-align: center;">
          <div class="carpet-option" data-carpet="bottom">
             <img src="bottom.png" alt="Bottom Carpet" onerror="this.style.display='none'; this.parentElement.style.background='linear-gradient(135deg, #6b4423 0%, #4a2f1a 100%)';">
          </div>
          <div class="carpet-label">Bottom</div>
        </div>
      </div>
    </div>
    
    <div id="carpetPage" class="page">
      <div class="controls">
        <button id="backBtn" class="btn btn-secondary">← Back</button>
        <span class="instructions">Draw to fade • Switch mode to restore</span>
        <div style="display: flex; gap: 10px;">
          <button id="modeBtn" class="btn">Restore Mode</button>
          <button id="resetBtn" class="btn btn-secondary">Reset</button>
        </div>
      </div>
      <div id="container">
        <canvas id="baseCanvas"></canvas>
        <canvas id="overlay"></canvas>
      </div>
    </div>
  </div>
</div>

<script>
  const baseCanvas = document.getElementById('baseCanvas');
  const overlay = document.getElementById('overlay');
  const baseCtx = baseCanvas.getContext('2d');
  const overlayCtx = overlay.getContext('2d');
  const onboardingPage = document.getElementById('onboarding');
  const carpetPage = document.getElementById('carpetPage');
  const instructionsSpan = document.querySelector('.instructions');
  
  let currentCarpet = null;
  let topImage = new Image();
  let isDrawing = false;
  let fadeMode = true; // true means the brush will FADE (lighten/desaturate)

  // --- Hidden Canvas for Brush Texture Masking ---
  const brushCanvas = document.createElement('canvas');
  const brushCtx = brushCanvas.getContext('2d');
  const BRUSH_RADIUS = 30;
  const BRUSH_DENSITY = 12;

  // Set the brush canvas size once
  brushCanvas.width = BRUSH_RADIUS * 2;
  brushCanvas.height = BRUSH_RADIUS * 2;

  // --- Helper Functions ---

  function drawBrushTexture() {
      // Clear the temporary brush canvas
      brushCtx.clearRect(0, 0, brushCanvas.width, brushCanvas.height);
      const center = BRUSH_RADIUS;
      
      brushCtx.fillStyle = 'rgba(0, 0, 0, 1)'; // Opaque shape for the stencil

      for (let i = 0; i < BRUSH_DENSITY; i++) {
          const offsetX = (Math.random() - 0.5) * BRUSH_RADIUS * 0.5;
          const offsetY = (Math.random() - 0.5) * BRUSH_RADIUS * 0.5;
          const smallRadius = BRUSH_RADIUS * (0.3 + Math.random() * 0.4);

          brushCtx.beginPath();
          // Draw small, randomly placed shapes for grain
          brushCtx.arc(center + offsetX, center + offsetY, smallRadius, 0, Math.PI * 2);
          brushCtx.fill();
      }
      return brushCanvas;
  }


  // --- Carpet Selection and Initialization ---
  
  document.querySelectorAll('.carpet-option').forEach(option => {
    option.addEventListener('click', () => {
      const carpetType = option.dataset.carpet;
      loadCarpet(carpetType);
    });
  });
  
  function loadCarpet(carpetType) {
    fadeMode = true;
    document.getElementById('modeBtn').textContent = 'Restore Mode'; // Shows next mode
    instructionsSpan.textContent = "Draw to fade • Switch mode to restore";

    currentCarpet = carpetType;
    topImage = new Image();
    topImage.crossOrigin = "anonymous";
    topImage.src = `${carpetType}.png`;
    
    topImage.onload = () => {
      init();
      onboardingPage.classList.remove('active');
      carpetPage.classList.add('active');
    };
    
    topImage.onerror = () => {
      console.error(`Failed to load ${carpetType}.png`);
      // Fallback: Create a sample carpet pattern
      baseCanvas.width = 700;
      baseCanvas.height = 900;
      overlay.width = 700;
      overlay.height = 900;
      
      baseCtx.fillStyle = carpetType === 'top' ? '#c9a582' : carpetType === 'middle' ? '#8b6f47' : '#4a2f1a';
      baseCtx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);
      
      baseCtx.strokeStyle = 'rgba(255,255,255,0.1)';
      baseCtx.lineWidth = 2;
      for (let i = 0; i < baseCanvas.width; i += 30) {
        for (let j = 0; j < baseCanvas.height; j += 30) {
          baseCtx.strokeRect(i, j, 30, 30);
        }
      }
      baseCtx.fillStyle = 'white';
      baseCtx.font = '20px Georgia';
      baseCtx.textAlign = 'center';
      baseCtx.fillText(`Draw on me! (${carpetType}.png not found)`, baseCanvas.width/2, 50);

      overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
      
      onboardingPage.classList.remove('active');
      carpetPage.classList.add('active');
    };
  }

  function init() {
    const maxWidth = 700;
    const maxHeight = 900;
    
    let scale = Math.min(maxWidth / topImage.width, maxHeight / topImage.height);
    
    baseCanvas.width = topImage.width * scale;
    baseCanvas.height = topImage.height * scale;
    overlay.width = baseCanvas.width;
    overlay.height = baseCanvas.height;
    
    // Draw original image to base canvas
    baseCtx.drawImage(topImage, 0, 0, baseCanvas.width, baseCanvas.height);
    
    // Clear the overlay to start fresh
    overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
    
    // CRITICAL: Draw the base image to the overlay once, with a color filter applied.
    // This pre-fades the *entire image*, so the drawing will erase it to restore the color.
    // To match your expectation (start full color, then fade), we skip this pre-fade.
    // Instead, the Fade Mode brush will apply the 'fade' only where it's drawn.
  }

  function getCanvasCoords(e) {
    const rect = overlay.getBoundingClientRect(); // Events on overlay now
    if (e.touches) {
      return {
        x: e.touches[0].clientX - rect.left,
        y: e.touches[0].clientY - rect.top
      };
    }
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }

  function drawBrush(x, y) {
    overlayCtx.save();
    
    // 1. Draw the textured shape onto the overlay canvas
    const brushTexture = drawBrushTexture();
    overlayCtx.drawImage(brushTexture, x - BRUSH_RADIUS, y - BRUSH_RADIUS);
    
    if (fadeMode) {
      // FADE MODE: Draw a semi-transparent, bright color over the stroke area.
      // This color must be drawn *on top of the current stroke*, so we need to
      // use globalCompositeOperation to only affect pixels *within the stroke shape*.

      // The drawn texture is the 'source' (the new pixels).
      // The image pixels underneath are the 'destination'.
      // We want to apply a color to the *image pixels* defined by the stroke.

      // CRITICAL FIX: To apply a *color filter* to the image pixels
      // defined by the stroke, we use globalCompositeOperation.
      // 'source-atop' allows us to color the image underneath without affecting the image structure.
      
      // The overlay is the drawing surface. We need a separate canvas to do the color math.
      baseCtx.save();
      baseCtx.globalCompositeOperation = 'source-atop';
      
      // Draw a semi-transparent, bright yellow/white gradient over the texture
      // This color will blend with the image pixels due to 'source-atop'
      const fadeColor = 'rgba(255, 255, 200, 0.4)'; // Light yellow for subtle desaturation/lightening
      baseCtx.fillStyle = fadeColor;
      
      // Use the texture as a clip mask (must be done on the same canvas)
      baseCtx.globalAlpha = 1;
      baseCtx.globalCompositeOperation = 'destination-in'; // Keep only where both this and destination exist
      
      baseCtx.drawImage(brushTexture, x - BRUSH_RADIUS, y - BRUSH_RADIUS);

      baseCtx.globalCompositeOperation = 'source-atop'; // Only draw new color over existing image
      baseCtx.fillStyle = fadeColor;
      baseCtx.fillRect(x - BRUSH_RADIUS, y - BRUSH_RADIUS, BRUSH_RADIUS * 2, BRUSH_RADIUS * 2);

      // This is still complex. The simplest way to apply a *filter* locally is to use
      // the `baseCtx` with a global filter applied to the whole canvas, then mask.
      
      // **REVERTING to the simplest and most effective technique for your goal: BLEND MODE**
      // Use the overlay to draw the light/desaturation color, and let the blend mode do the work.
      
      overlayCtx.globalCompositeOperation = 'source-over'; // Draw the texture onto the overlay
      overlayCtx.globalAlpha = 0.5; // Controls the strength of the fade
      overlayCtx.fillStyle = 'rgba(255, 255, 255, 1)'; // Use opaque white for the texture

      // Now, apply the color blend mode to the *entire overlay layer*
      // This will cause the white texture drawn to blend with the base canvas
      overlay.style.mixBlendMode = 'lighten'; // Mix blend mode lightens/desaturates colors

    } else {
      // RESTORE MODE: Erase the overlay (removing the fade effect).
      overlayCtx.globalCompositeOperation = 'destination-out';
      overlayCtx.globalAlpha = 1; // Opaque erasing for full restoration
      overlayCtx.fillStyle = 'rgba(0, 0, 0, 1)'; // Erasing color doesn't matter, only opacity

      // Draw the texture shape for erasing
      overlayCtx.drawImage(brushTexture, x - BRUSH_RADIUS, y - BRUSH_RADIUS);
    }
    
    overlayCtx.restore();
  }

  function startDrawing(e) {
    e.preventDefault();
    isDrawing = true;
    const coords = getCanvasCoords(e);
    // Draw first dot and start tracking stroke
    drawBrush(coords.x, coords.y);
  }

  function draw(e) {
    e.preventDefault();
    if (!isDrawing) return;
    const coords = getCanvasCoords(e);
    // Draw continuously
    drawBrush(coords.x, coords.y);
  }

  function stopDrawing(e) {
    e.preventDefault();
    isDrawing = false;
  }

  // Mouse events are on the TOP layer (#overlay)
  overlay.addEventListener('mousedown', startDrawing);
  overlay.addEventListener('mousemove', draw);
  overlay.addEventListener('mouseup', stopDrawing);
  overlay.addEventListener('mouseleave', stopDrawing);

  // Touch events
  overlay.addEventListener('touchstart', startDrawing);
  overlay.addEventListener('touchmove', draw);
  overlay.addEventListener('touchend', stopDrawing);

  // --- Buttons ---
  
  document.getElementById('resetBtn').addEventListener('click', () => {
    // Reset clears the overlay canvas, removing all fade effects
    overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
  });

  document.getElementById('modeBtn').addEventListener('click', () => {
    fadeMode = !fadeMode;
    document.getElementById('modeBtn').textContent = fadeMode ? 'Restore Mode' : 'Fade Mode';
    instructionsSpan.textContent = fadeMode ? "Draw to fade • Switch mode to restore" : "Draw to restore • Switch mode to fade";
  });
  
  document.getElementById('backBtn').addEventListener('click', () => {
    carpetPage.classList.remove('active');
    onboardingPage.classList.add('active');
    overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
  });
</script>
</body>
</html>
